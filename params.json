{"name":"Githubtrends","tagline":"Decoding the GitHub social coding phenomena","body":"# **Problem Overview and solution**\r\n\r\n## _Problem Statement_\r\n\r\nFind the relationships between the watchers/committers with the popularity of a repo. How does the push/watch event of a highly popular user affect the growth curve of a GitHub repository?\r\n\r\n## _Dataset_\r\n\r\nThe dataset is in the form of JSON dumps of GitHub activity of various repositories and users.  Please find the sample files [here](https://github.com/geekypunk/GitHubTrends/tree/master/sampleJSONs)\r\n\r\n## _Solution_\r\n\r\nThe solution attempts to find the correlations between user events on a repository and its effects on the growth curve. The approach is fairly straightforward.\r\n\r\n### Algorithm\r\n\r\n* •\tFirst select the topmost users aka high profile users (defined having highest number of followers). This is information is obtained from FollowEvents SQL dump, created using all the FollowEvents in the JSON dump \r\n* •\tThen get all the WatchEvents of each of these high profile users\r\n* o\tFor every WatchEvent by a user on a repository, get all the events on that repo till 24 hours after the WatchEvent. \r\n* o\tDraw a growth curve for this repository based on the above 1 day events. The x-axis contains the timestamps represented as float values and y-axis has the number of watchers of the repo at the respective timestamps\r\n* o\tWe first determine the plot’s eligibility to be drawn. We draw a plot if the growth curve shows substantial deviation from its predicted curve. The predicted curve is drawn since the timestamp of the WatchEvent. The data prior to this event is used for prediction. Least squares polynomial fitting is used to draw the curve. \r\n* o\tThen we determine the genuineness of a user’s impact (explained later) on that repo. If a user’s WatchEvent has actually caused the change in the growth curve, the plot of that repo is generated and stored in an image file\r\n* •\tUsing the above generated growth curve, we also try to observe as how group dynamics work in social coding. Do some users act as flock when one of them starts watching a repo? See User dynamics section for more info\r\n\r\n### Implementation\r\nThe python implementation for the above algorithm can be found [here](https://github.com/geekypunk/GitHubTrends/blob/master/python/highProfileWatchEvents.py). \r\n\r\n### Genuineness of a user’s impact\r\nSince the change in the growth curve of a repository need not be influenced by a WatchEvent of a particular user, we try to estimate as how genuine his WatchEvent is. The algorithm used for this is as follows\r\n* o\tGet all the changes in watch counts of all the repos he has started watching. The initial and final watch counts differ by a timestamp of 1 day.\r\n* o\tCalculate the standard deviation of all these differences.\r\n* o\tIf the standard is low “enough”, we deem the impact to be genuine, i.e the growth change has happened due to the user watching the repo\r\n\r\n## User Dynamics\r\n\r\nThis section explains the methodology used to observe user behavior in the social coding context. Do user operate in flock, when one of them starts following a repo? Which users most “connected”, i.e. the users most probable to start watching a repo, when one of them does?\r\n## Algorithm\r\n* o\tUsing the growth curve generated from the above algorithm, we can create lists of chronological user sequences. Each sequence contains a list of usernames, which represents the all the users,in-order,who have started watching the repo after the first user in the list has.\r\n* o\tFor example for a repo, if the first WatchEvent was by a high profile user called A, and the subsequent watch events on the repo till 1 day after that were by B C D and E. The list would look like [A,B,C,D,E]  \r\n* o\tSo essentially we will have a list of such sequences.\r\n* o\tNow, to determine the user groups which are most “close”, we simply need to determine the subsequences which are most common among all the sequences in the list. We say sub-sequence and not sequence as the users need not appear in the exact same order in every sequence encountered, but just should be chronologically same.  For example if A appears before C in a sequence, and same is in another sequence, it is safe to assume A’s influence on C. This assumption is only valid upto a certain distance between the two users. As the longer is the gap between two users in a sequence, lower is their “connectivity”, i.e lower is A’s influence on C.(Currently working on accommodating this logic)\r\n* o\tThis high co-incidence user groups is obtained by maintaining a map of all possible permutations, of all the sequences encountered so far as we iterate the list of sequences. Whenever we see an already seen permutation, we increment its occurrence count.\r\n\r\n### Sub-Algorithm\r\n`\r\n`Input :  List on chronological user sequences S\r\n\t\tOutput : Count map, M, representing the occurrence count of all sub-sequences\r\n\r\n\t\tFor all sequences Q in S:\r\n\t\t\tFor every possible permutation P of sequence Q in map M:\r\n\t\t\t\tCheck if P already present in M:\r\n\t\t\t\t\tIf True:\r\n\t\t\t\t\t\tM[P]++   //Increase the occurrence count\r\n## Implementation\r\nThe python implementation for the above algorithm can be found here.  The script takes two command-line arguments, first one is the size of user sets and second is how many such top sets.\r\nFor example,\r\nIf we need the top 5 users sets each of size 3 who show high connectivity, issue the command\r\n\t\tpython getFlockUsers.py 3 5\r\n#Code setup\r\n* •\tPut appropriate database credentials in def getDBConnection() function of  highProfileWatchEvents.py\r\n* •\tImport the sql files from here\r\n* •\tRun highProfileWatchEvents.py  to generate plots\r\nGenerated Growth Curve Plots\r\n\r\nHere is a sample of generated plot images of the repo. \r\n \r\n \r\n \r\n##Plot properties\r\n* •\tX-axis indicates the timestamps\r\n* •\tY-axis indicates watcher counts at respective timestamps\r\n* •\tThe first red line(impactStart) indicates the timestamp of the high profile WatchEvent\r\n* •\tThe second red line(impactEnd) is 24 hours after impactStart\r\n* •\tThe text below the plot is of the format\r\n* o\tUSER-> URL of the repo he impacted\r\n\r\n#Observations\r\n\r\n•\tBy looking at the plot images, most of the plots show an increased growth rate after a high profile user starts watching. The rate slowly saturates with time\r\n•\tIf a user has particularly high number of followers, the growth rate increases substantially\r\n•\tIf a user has lower than average number of followers(average calculated from the data), the chance of the growth rate being continually increasing is less, showing that the growth rate is mostly independent of his impact\r\n•\tThe growth rates of very popular repos seem not to differ much, even when a high profile user starts watching\r\n•\tMost of the \"social\" effect is seen within 1 day of the event, similar behavior is also observed during news proliferation in social networking sites like Facebook. Here the workflow is usually like...User watches a repo->His followers get notified; follow the repo->Their followers. So on.\r\n•\tUser do seem to behave in groups, a distinct set of users show high co-incidence, i.e if a user’s starts watching another set users are most probable to follow that repository. The below are set of two users, with their incidence count\r\no\t(('torifat', 'mkol5222'), 642)\r\no\t(('fnu', 'torifat'), 452)\r\no\t(('jasolko', 'fnu'), 342)\r\no\t(('hansstimer', 'payco'), 152)\r\no\t(('rgigger', 'roundhead',32)\r\n\r\nThe below are set of three users, with their incidence count\r\n\r\no\t(('anggriawan', 'rgigger', 'jasolko'), 314)\r\no\t(('fnu', 'jasolko', 'torifat'), 134)\r\no\t(('payco', 'roundhead', 'rgigger'), 78)\r\no\t(('fnu', 'hansstimer', 'torifat'), 34)\r\no\t(('rgigger', 'anggriawan', 'payco'), 29)\r\n\r\n\r\n#Dataset statistics\r\n\r\nTotal Repos: 296456\r\n\r\nTop 10 popular repos\r\n\r\n           Repo_url                                    \t\t\twatchers      forks       stargazers\r\n                  \r\n1     https://github.com/twitter/bootstrap            \t\t 28810         \t 0    \t\t5623\r\n2     https://github.com/jquery/jquery              \t\t 16167      16167  \t\t  2025\r\n3     https://github.com/joyent/node                 \t\t14964          0    \t\t1794\r\n4     https://github.com/h5bp/html5-boilerplate       \t 14263      14263  \t\t  2259\r\n5     https://github.com/rails/rails                \t\t\t 14158          0    \t\t3164\r\n6     https://github.com/octocat/Spoon-Knife            \t 10590      10590  \t\t  8838\r\n7     https://github.com/mxcl/homebrew             \t \t 9602           9602    \t\t4358\r\n8     https://github.com/bartaz/impress.js           \t \t 8594          0   \t\t 1277\r\n9     https://github.com/documentcloud/backbone  \t 8272          0    \t\t1099\r\n10   https://github.com/mrdoob/three.js             \t\t 7607           7607  \t\t  972\r\n\r\n\r\n\r\n\r\nTop 10 followed Users\r\n1             defunkt\r\n2             mojombo\r\n3             torvalds\r\n4             jeresig\r\n5             schacon\r\n6             paulirish\r\n7             ryanb\r\n8             pjhyett\r\n9             visionmedia\r\n10           dhh\r\n\r\n\r\n\r\nTop 10 events by count\r\n\r\n          eventType         count(eventType)\r\n1          PushEvent                   140380\r\n2        CreateEvent                42900\r\n3         WatchEvent                29360\r\n4      IssueCommentEvent            20887\r\n5        IssuesEvent                13682\r\n6          ForkEvent                 9967\r\n7          GistEvent                 9082\r\n8       PullRequestEvent             8419\r\n9        FollowEvent                 7592\r\n10       GollumEvent                 4999\r\n\r\n10 fastest growing repositories by number of watchers\r\n\r\n                repo_url                     FROM  TO\r\n1          https://github.com/mbostock/d3              5346    14027\r\n2          https://github.com/twitter/bootstrap             27717    36352\r\n3          https://github.com/textmate/textmate         1      6532\r\n4             https://github.com/adobe/brackets            29      5935\r\n5          https://github.com/rails/rails                 13986     18009\r\n6      https://github.com/AFNetworking/AFNetworking      2557      6406\r\n7       https://github.com/FortAwesome/Font-Awesome      3333      6442\r\n8             https://github.com/xing/wysihtml5               603      3652\r\n9          https://github.com/HPNeo/gmaps            19      2943\r\n10         https://github.com/ivaynberg/select2            49      2665\r\n\r\nTop 10 Most active repos by event counts\r\n\r\n2      https://github.com/eclipse/eclipse.platform.common       CreateEvent           11903\r\n3          https://github.com/nyarlabo/websites                 PushEvent            4341\r\n4        https://github.com/itroot/reach-github-limit             PushEvent             854\r\n5          https://github.com/haskell/cabal                IssueCommentEvent   518\r\n6          https://github.com/rails/rails                      PullRequestEvent         515\r\n7          https://github.com/entoo/portage                     PushEvent             442\r\n8          https://github.com/pulWifi/pulWifi                   IssuesEvent             424\r\n9          https://github.com/mxcl/homebrew                 IssueCommentEvent   406\r\n10        https://github.com/twitter/bootstrap                WatchEvent             373\r\n11          https://github.com/KernCZ/tomato-firmware           CreateEvent             334\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}